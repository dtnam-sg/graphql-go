package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.65

import (
	"context"
	"crypto/rand"
	"fmt"
	"graphql-demo/graph"
	"graphql-demo/graph/helper"
	"graphql-demo/graph/model"
	"log"
	"math/big"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.UserMutationPayload, error) {
	log.Printf("CreateUser: %v\n", input)
	randID, _ := rand.Int(rand.Reader, big.NewInt(100))
	roles, err := helper.FindRoles(input, r.roles)

	if err != nil {
		return nil, fmt.Errorf("error finding roles: %v", err)
	}

	functions, err := helper.FindFunctions(input, r.functions)
	if err != nil {
		return nil, fmt.Errorf("error finding functions: %v", err)
	}

	user := &model.User{
		ID:        fmt.Sprintf("user-%d", randID),
		Name:      input.Name,
		Email:     input.Email,
		Roles:     roles,
		Functions: functions,
		BaseInfo:  helper.NewBaseInfoWithDefault(),
	}
	r.users = append(r.users, user)
	return &model.UserMutationPayload{
		Success: true,
		User:    user,
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.CreateUserInput) (*model.UserMutationPayload, error) {
	log.Printf("UpdateUser: %v\n", input)
	roles, err := helper.FindRoles(input, r.roles)
	if err != nil {
		return nil, fmt.Errorf("error finding roles: %v", err)
	}

	functions, err := helper.FindFunctions(input, r.functions)
	if err != nil {
		return nil, fmt.Errorf("error finding functions: %v", err)
	}
	for _, user := range r.users {
		if user.ID == id {
			user.Email = input.Email
			user.Name = input.Name
			user.Roles = roles
			user.Functions = functions
			return &model.UserMutationPayload{
				Success: true,
				User:    user,
			}, nil
		}
	}
	return &model.UserMutationPayload{
		Success: false,
	}, fmt.Errorf("update user not found")
}

// InviteUser is the resolver for the inviteUser field.
func (r *mutationResolver) InviteUser(ctx context.Context, input model.InviteUserInput) (bool, error) {
	log.Printf("InviteUser: %v\n", input)
	return true, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (*model.UserMutationPayload, error) {
	log.Printf("DeleteUser: %v\n", id)
	for i, user := range r.users {
		if user.ID == id {
			r.users = append(r.users[:i], r.users[i+1:]...)
			return &model.UserMutationPayload{
				Success: true,
				User:    user,
			}, nil
		}
	}
	return &model.UserMutationPayload{
		Success: false,
	}, fmt.Errorf("user not found")
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, filter *model.UserFilter, pagination *model.PaginationInput) (*model.Users, error) {
	log.Printf("Users: %v\n", filter)
	filteredUsers := r.users
	if filter != nil {
		var temp []*model.User
		for _, user := range filteredUsers {
			// Filter by name
			if filter.Name != nil && *filter.Name != "" {
				if user.Name != *filter.Name {
					continue
				}
			}

			// Filter by email
			if filter.Email != nil && *filter.Email != "" {
				if user.Email != *filter.Email {
					continue
				}
			}

			// Filter by role ID
			if filter.RoleIds != nil && *filter.RoleIds != "" {
				found := false
				for _, role := range user.Roles {
					if role.ID == *filter.RoleIds {
						found = true
						break
					}
				}
				if !found {
					continue
				}
			}

			temp = append(temp, user)
		}
		filteredUsers = temp
	}

	// Apply pagination
	if pagination != nil {
		page := 1
		if pagination.Page != nil {
			page = int(*pagination.Page)
		}

		limit := 10
		if pagination.Size != nil {
			limit = int(*pagination.Size)
		}

		start := (page - 1) * limit
		end := start + limit

		if start >= len(filteredUsers) {
			return &model.Users{
				Users: filteredUsers,
				Total: int32(len(filteredUsers)),
			}, nil
		}

		if end > len(filteredUsers) {
			end = len(filteredUsers)
		}

		filteredUsers = filteredUsers[start:end]

	}

	return &model.Users{
		Users: filteredUsers,
		Total: int32(len(r.users))}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	log.Printf("User By ID: %v\n", id)
	for _, user := range r.users {
		if user.ID == id {
			return user, nil
		}
	}
	return nil, fmt.Errorf("user not found")
}

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
